local LoaderLibrary = loadstring(game:HttpGet("https://raw.githubusercontent.com/3345-c-a-t-s-u-s/StackFlow/refs/heads/main/src.lua"))()
local Library = typeof(LoaderLibrary) == "function" and LoaderLibrary() or LoaderLibrary
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- ⚙️ Настройки
local ARREST_RADIUS = 10
local ARREST_INTERVAL = 0.5
local TASER_RANGE = 50
local TASER_RADIUS = 50
local TASER_INTERVAL = 0.1
local BEAM_DURATION = 0.3

-- 🔧 Ссылки
local DetainmentEvent = ReplicatedStorage:WaitForChild("Remote"):WaitForChild("Detainment")
local RunService = game:GetService("RunService")
local Window = Library.new()
Window:load()

local PlayerTab = Window:create_tab("Player", "rbxassetid://10723407389")
local VisualsTab = Window:create_tab("Visuals", "rbxassetid://10723407389")
local WalkSpeedModule = PlayerTab:create_module({
  	rich = false,
	section = 'right',
	title = "WalkSpeed",
	description = "SpeedHack wahahahahatatatt????",
    flag = "MasterSwitch",
    callback = function(state)
        print("WalkSpeed MasterSwitch:", state)
    end
})

local speedEnabled = false
WalkSpeedModule:create_checkbox({
    title = "WS",
    flag = "speed_enabled",
    callback = function(val)
        speedEnabled = val
    end
})

local Player = game:GetService("Players").LocalPlayer
local aux = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/Upbolt/Hydroxide/revision/ohaux.lua"))()

-- Путь до нужного скрипта
local scriptPath = Player.PlayerScripts.RunPlayerScripts.Movement
local closureName = "onStepped"
local closureConstants = {
	[1] = 0,
	[2] = "EXTRASPEED",
	[3] = "GetAttribute",
	[4] = 4,
	[5] = "MoveDirection",
	[6] = "Magnitude"
}

-- Находим upvalues
local closure1 = aux.searchClosure(scriptPath, closureName, 3, closureConstants)
local closure2 = aux.searchClosure(scriptPath, closureName, 4, closureConstants)


WalkSpeedModule:create_checkbox({
	title = "inf stamina",
	flag = "ExtraSpeed",
	callback = function(state)
		if state then
			-- Включено: ставим 999+
			debug.setupvalue(closure1, 3, math.huge)
			debug.setupvalue(closure2, 4, math.huge)
		else
			-- Выключено: возвращаем обычное значение
			debug.setupvalue(closure1, 3, 100)
			debug.setupvalue(closure2, 4, 100)
		end
	end
})


local speedValue = 16
local slider = WalkSpeedModule:create_slider({
	title = "WalkSpeed",
	value = 16,
	round_number = 1,
	minimum_value = 16,
	maximum_value = 100,
	flag = 'WalkValue',
	callback = function(a)
		speedValue = a
	end,
});

local HipEnabled = false
WalkSpeedModule:create_checkbox({
    title = "HipHeight",
    flag = "Hip_enabled",
    callback = function(val)
        HipEnabled = val
    end
})

local HipValue = 0
local slider = WalkSpeedModule:create_slider({
	title = "HipHeight",
	value = 0,
	round_number = 0.1,
	minimum_value = 0,
	maximum_value = 100,
	flag = 'HipValue',
	callback = function(a)
		HipValue = a
	end,
});

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

RunService.RenderStepped:Connect(function()
    local char = player.Character
    if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") then
        if WalkSpeedModule._state and speedEnabled then
            local moveDir = char.Humanoid.MoveDirection
            if moveDir.Magnitude > 0 and speedValue > 16 then
                char.HumanoidRootPart.CFrame = char.HumanoidRootPart.CFrame + moveDir * (speedValue / 100)
            end
        end
    end
end)

RunService.RenderStepped:Connect(function()
    local char = player.Character
    if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChild("Humanoid") then
        if WalkSpeedModule._state and HipEnabled then
            player.Character.Humanoid.HipHeight = HipValue
        end
    end
end)

local TPHandsModule = PlayerTab:create_module({
  	rich = false,
	section = 'left',
	title = "TP Hands",
	description = "Expanded Hitbox 'not'",
    flag = "TPHandsModule_Master",
    callback = function(state)
        print("TPHandsModule_Master:", state)
    end
})

local trapRadius = 10
local armDistance = 3
local highlight

TPHandsModule:create_slider({
	title = "Radius",
	value = trapRadius,
	round_number = 1,
	minimum_value = 5,
	maximum_value = 20,
	flag = 'TrapValue',
	callback = function(a)
		trapRadius = a
	end,
});

local trapEnemy = false
TPHandsModule:create_checkbox({
    title = "Включить TP Hands",
    flag = "tphands_enabled",
    callback = function(Value)
        trapEnemy = Value
        
        if not trapEnemy and highlight then
            highlight:Destroy()
            highlight = nil
        end

        if trapEnemy then
            RunService.RenderStepped:Connect(function()
                if not trapEnemy then return end
                local char = player.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                if not hrp then return end

                local nearest, nearestDist
                for _,plr in pairs(Players:GetPlayers()) do
                    if plr ~= player and plr.Character then
                        local hrpEnemy = plr.Character:FindFirstChild("HumanoidRootPart")
                        if hrpEnemy then
                            local dist = (hrpEnemy.Position - hrp.Position).Magnitude
                            if dist <= trapRadius and (not nearestDist or dist < nearestDist) then
                                nearest = plr.Character
                                nearestDist = dist
                            end
                        end
                    end
                end

                if nearest then
                    local leftArm = nearest:FindFirstChild("Left Arm")
                    local rightArm = nearest:FindFirstChild("Right Arm")

                    local function setNoCollide(obj)
                        for _, child in ipairs(obj:GetDescendants()) do
                            if child:IsA("BasePart") then
                                child.CanCollide = false
                            end
                        end
                    end

                    if leftArm and nearest:FindFirstChild("Torso") then
                        local ls = nearest.Torso:FindFirstChild("Left Shoulder")
                        if ls then ls:Destroy() end
                    end
                    if rightArm and nearest:FindFirstChild("Torso") then
                        local rs = nearest.Torso:FindFirstChild("Right Shoulder")
                        if rs then rs:Destroy() end
                    end

                    for _, tool in ipairs(nearest:GetChildren()) do
                        if tool:IsA("Tool") then
                            setNoCollide(tool)
                        end
                    end

                    if not highlight or highlight.Parent ~= nearest then
                        if highlight then highlight:Destroy() end
                        highlight = Instance.new("Highlight")
                        highlight.Parent = nearest
                        highlight.FillColor = Color3.fromRGB(255,0,0)
                        highlight.OutlineColor = Color3.fromRGB(150,0,0)
                        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    end

                    local leftPos = hrp.CFrame * CFrame.new(-1.5, 0, -armDistance)
                    local rightPos = hrp.CFrame * CFrame.new(1.5, 0, -armDistance)

                    if leftArm then leftArm.CFrame = CFrame.new(leftPos.Position, hrp.Position) end
                    if rightArm then rightArm.CFrame = CFrame.new(rightPos.Position, hrp.Position) end
                else
                    if highlight then
                        highlight:Destroy()
                        highlight = nil
                    end
                end
            end)
        end
    end
})

local malienabled = false

local MaliciousModule = PlayerTab:create_module({
    rich = false,
    section = 'left',
    title = "Malicious",
    description = "Others :)",
    flag = "MaliciousModule_Master",
    callback = function(state)
        malienabled = state
    end
})

local Players = game:GetService("Players")
local VirtualUser = game:GetService("VirtualUser")
local player = Players.LocalPlayer

local AntiAFKEnabled = false
local AntiAFKConnection

MaliciousModule:create_checkbox({
    title = "Anti-AFK",
    flag = "antiAFK_enabled",
    callback = function(val)
        AntiAFKEnabled = val

        if AntiAFKEnabled then
            Library.SendNotification({
                title = "Anti-AFK",
                text = "AntiAFK Enabled",
                duration = 3
            })

            AntiAFKConnection = player.Idled:Connect(function()
                VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
                task.wait(1)
                VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
            end)
        else
            if AntiAFKConnection then
                AntiAFKConnection:Disconnect()
                AntiAFKConnection = nil
            end

            Library.SendNotification({
                title = "Anti-AFK",
                text = "AntiAFK Disabled",
                duration = 3
            })
        end
    end
})

MaliciousModule:create_button({
    title = "Bypass Alt Ban [Only Rejoin]",
    callback = function()
        for _, obj in pairs(game.ReplicatedStorage:GetChildren()) do
            obj:Destroy()
        end
    end
})

MaliciousModule:create_button({
    title = "PickUp Stolen Elevator Card",
    callback = function()
        local args = {
			workspace:WaitForChild("Ignored"):WaitForChild("DroppedTools"):WaitForChild("Stolen Elevator Card")
		}
		game:GetService("ReplicatedStorage"):WaitForChild("Remote"):WaitForChild("RequestPickup"):FireServer(unpack(args))
    end
})

MaliciousModule:create_button({
    title = "PickUp Stolen Staff Card",
    callback = function()
        local args = {
			workspace:WaitForChild("Ignored"):WaitForChild("DroppedTools"):WaitForChild("Stolen Staff Card")
		}
		game:GetService("ReplicatedStorage"):WaitForChild("Remote"):WaitForChild("RequestPickup"):FireServer(unpack(args))
    end
})

MaliciousModule:create_button({
    title = "GodMode",
    callback = function()
        local sound = Instance.new("Sound")
		sound.SoundId = "rbxassetid://100930491757050"
		sound.Volume = 10
		sound.PlayOnRemove = false
		sound.Looped = false
		sound.Parent = workspace

		local reverb = Instance.new("ReverbSoundEffect")
		reverb.DecayTime = 2.5 
		reverb.Density = 0.7 
		reverb.WetLevel = 0 
		reverb.DryLevel = 0
		reverb.Parent = sound

		sound:Play()

		sound.Ended:Connect(function()
			sound:Destroy()
		end)
    end
})

local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local AntiRagdollEnabled = false
local speed = 10
local keys = {W=false,A=false,S=false,D=false,Space=false,Shift=false}

local hrp, humanoid

local function setupCharacter(char)
    hrp = char:WaitForChild("HumanoidRootPart")
    humanoid = char:WaitForChild("Humanoid")
end

if player.Character then
    setupCharacter(player.Character)
end

player.CharacterAdded:Connect(setupCharacter)

MaliciousModule:create_checkbox({ 
    title = "AntiRagdoll", 
    flag = "AntiRagdollEnabled",
    callback = function(val)
        AntiRagdollEnabled = val
    end
})

UIS.InputBegan:Connect(function(input, gp)
    if gp then return end
    local key = input.KeyCode.Name
    if keys[key] ~= nil then keys[key] = true end
end)
UIS.InputEnded:Connect(function(input)
    local key = input.KeyCode.Name
    if keys[key] ~= nil then keys[key] = false end
end)

local flySpeed = 3
local lerpFactor = 0.15

RunService.RenderStepped:Connect(function()
    if not malienabled or not AntiRagdollEnabled then return end
    if not hrp or not humanoid then return end
    if humanoid.Health <= 0 then return end
    if not humanoid.PlatformStand then return end

    local camCF = workspace.CurrentCamera.CFrame
    local moveDir = Vector3.zero

    if keys.W then moveDir += camCF.LookVector end
    if keys.S then moveDir -= camCF.LookVector end
    if keys.A then moveDir -= camCF.RightVector end
    if keys.D then moveDir += camCF.RightVector end
    if keys.Space then moveDir += Vector3.new(0,1,0) end
    if keys.Shift then moveDir -= Vector3.new(0,1,0) end

    if moveDir.Magnitude > 0 then
        moveDir = moveDir.Unit * flySpeed
        local targetCFrame = hrp.CFrame + moveDir
        hrp.CFrame = hrp.CFrame:Lerp(targetCFrame, lerpFactor)
    end
end)

local AutoFarm = PlayerTab:create_module({
  	rich = false,
	section = 'right',
	title = "AutoFarm",
	description = " ",
    flag = "AutoFarm",
    callback = function(state)
        print("AutoFarm MasterSwitch:", state)
    end
})

local SkipTutorialEnabled = false
AutoFarm:create_checkbox({
    title = "Skip Tutorial",
    flag = "SkipTutorial_enabled",
    callback = function(val)
        SkipTutorialEnabled = val

        if SkipTutorialEnabled == true then
            for i = 1, 5 do
                local args = {"StepCompleted"}
                game:GetService("ReplicatedStorage"):WaitForChild("Remote"):WaitForChild("MissionProgressEvent"):FireServer(unpack(args))
            end

            do
                local args = {"GlassShard"}
                game:GetService("ReplicatedStorage"):WaitForChild("Remote"):WaitForChild("MissionProgressEvent"):FireServer(unpack(args))
            end

            do
                local args = {"TutorialFinished"}
                game:GetService("ReplicatedStorage"):WaitForChild("Remote"):WaitForChild("MissionProgressEvent"):FireServer(unpack(args))
            end

            do
                local args = {"Funnel", "FTUE", "Claimed Daily Rewards"}
                game:GetService("ReplicatedStorage"):WaitForChild("Remote"):WaitForChild("AnalyticsEvent"):FireServer(unpack(args))
            end
        end
    end
})

-- Настройки
local AutoescapeEnabled = false

AutoFarm:create_checkbox({
    title = "AutoEscape",
    flag = "Autoescape_enabled",
    callback = function(val)
        AutoescapeEnabled = val
    end
})

-- Позиции
local startPos = Vector3.new(-1.3597952127456665, 517.4800415039062, 521.6738891601562)
local endPos = Vector3.new(-2.7573933601379395, 517.4800415039062, 457.8841247558594)

local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer

-- Основной цикл
task.spawn(function()
    while task.wait(1) do
        if AutoescapeEnabled then
            local character = player.Character or player.CharacterAdded:Wait()
            local root = character:WaitForChild("HumanoidRootPart")

            -- 1. Телепортируем к первой точке
            root.CFrame = CFrame.new(startPos)
            task.wait(1)

            -- 2. Идём к следующей точке плавно (твины)
            local tween = TweenService:Create(root, TweenInfo.new(3, Enum.EasingStyle.Linear), {CFrame = CFrame.new(endPos)})
            tween:Play()
            tween.Completed:Wait()

            -- 3. Ждём случайное время
            local waitTime = math.random(50, 80)
            print("[AutoEscape] Wait "..waitTime.." secounds.")
            task.wait(waitTime)
        end
    end
end)


local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local autoFarmEnabled = false

AutoFarm:create_checkbox({
    title = "AutoFarm Spills",
    flag = "autofarm_enabled",
    callback = function(val)
        autoFarmEnabled = val
    end
})

RunService.Heartbeat:Connect(function()
    if autoFarmEnabled then
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        local spillsFolder = workspace:FindFirstChild("Ignored") 
                           and workspace.Ignored:FindFirstChild("Spills")
        if not spillsFolder then return end

        local nearestSpill
        local nearestDist
        for _, spill in pairs(spillsFolder:GetChildren()) do
            local pos
            if spill:IsA("Model") then
                if spill.PrimaryPart then
                    pos = spill.PrimaryPart.Position
                else
                    pos = nil
                end
            elseif spill:IsA("BasePart") then
                pos = spill.Position
            end

            if pos then
                local dist = (hrp.Position - pos).Magnitude
                if not nearestDist or dist < nearestDist then
                    nearestSpill = spill
                    nearestDist = dist
                end
            end
        end

        if nearestSpill then
            local targetCFrame
            if nearestSpill:IsA("Model") and nearestSpill.PrimaryPart then
                targetCFrame = nearestSpill.PrimaryPart.CFrame
            elseif nearestSpill:IsA("BasePart") then
                targetCFrame = nearestSpill.CFrame
            end

            if targetCFrame then
                hrp.CFrame = targetCFrame + Vector3.new(0, 3, 0)

                local args
                if nearestSpill:IsA("Model") then
                    args = {nearestSpill}
                else
                    args = {nearestSpill}
                end

                local remote = game:GetService("ReplicatedStorage"):WaitForChild("Remote"):WaitForChild("AttemptCleanSpill")
                remote:FireServer(unpack(args))
            end
        end
    end
end)

-- // 🔪 МОДУЛЬ: Killaura с выбором оружия, отображением таргета и проверкой друзей

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local Namespaces = require(ReplicatedStorage.Service.Namespaces)
local MeleeReplication = Namespaces.MeleeReplication

-- Списки оружия
local taserWeapons = {"Handheld Taser"}
local meleeWeapons = {"Electroshield","Door & Glass Shard","Metal Shard","Crowbar","Shove","Glass Fragment","Glass Shard","Wooden Bat","Stunstick","Riot Control"}

-- Настройки Killaura
local killauraEnabled = false
local showTarget = false
local killauraRadius = 10
local lastHitTime = 0
local hitCooldown = 0.5
local Killaura_Module = false
local ignoreFriends = true -- Новая настройка: игнорировать друзей
local friendsList = {} -- Список друзей

-- Форма, которую нужно игнорировать (например, охранники)
local IGNORE_SHIRT = "rbxassetid://12001628840"
local IGNORE_PANTS = "rbxassetid://12001628486"

-- Проверка формы игрока
local function hasIgnoreUniform(player)
	local char = player.Character
	if not char then return false end

	local shirt = char:FindFirstChildOfClass("Shirt")
	local pants = char:FindFirstChildOfClass("Pants")

	if not shirt or not pants then return false end

	return (shirt.ShirtTemplate == IGNORE_SHIRT and pants.PantsTemplate == IGNORE_PANTS)
end

local KillauraModule = PlayerTab:create_module({
	rich = false,
	section = 'right',
	title = "Killaura",
	description = "Автоматическая атака рядом стоящих игроков",
	flag = "Killaura_Modulew",
	callback = function(state)
		Killaura_Module = state
	end
})

local targetHighlight = Instance.new("SelectionBox")
targetHighlight.Adornee = nil
targetHighlight.LineThickness = 0.05
targetHighlight.Color3 = Color3.fromRGB(255,0,0)
targetHighlight.Parent = workspace

-- Функция проверки друга
local function isFriend(player)
	if not ignoreFriends then return false end

	local success, isFriendResult = pcall(function()
		return Players.LocalPlayer:IsFriendsWith(player.UserId)
	end)

	if success and isFriendResult then
		return true
	end

	if friendsList[player.Name] then
		return true
	end

	return false
end

local function addFriend(playerName)
	friendsList[playerName] = true
	Library.SendNotification({
		title = "Killaura",
		text = "Добавлен в список друзей: " .. playerName,
		duration = 3
	})
end

local function removeFriend(playerName)
	friendsList[playerName] = nil
	Library.SendNotification({
		title = "Killaura",
		text = "Удален из списка друзей: " .. playerName,
		duration = 3
	})
end

-- Функция выбора оружия
local function getEquippedWeapon()
	local localPlayer = Players.LocalPlayer
	if not localPlayer.Character then return nil end

	for _, name in ipairs(taserWeapons) do
		local weapon = localPlayer.Character:FindFirstChild(name)
		if weapon then return weapon end
	end

	for _, name in ipairs(meleeWeapons) do
		local weapon = localPlayer.Character:FindFirstChild(name)
		if weapon then return weapon end
	end
	return nil
end

-- Функция удара
local function fireHit(targetPlayer)
	local weapon = getEquippedWeapon()
	if not weapon then return end

	if targetPlayer and targetPlayer.Character then
		local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
		local targetPart = targetPlayer.Character:FindFirstChild("Head")
		if humanoid and targetPart then
			pcall(function()
				if MeleeReplication 
					and MeleeReplication.packets 
					and MeleeReplication.packets.sendHit 
					and MeleeReplication.packets.sendHit.send then
					MeleeReplication.packets.sendHit.send({humanoid, targetPart, weapon})
				end
			end)
		end
	end
end

local ignoreTeamsForOrderly = {
    AFFILIATE = true,
    BOXED = true,
    CHOOSING = true,
    COMMUNITY = true,
    DEVELOPER = true,
    ETHICS = true,
    HEADMANAGEMENT = true,
    IGNOTUS = true,
    JANITOR = true,
    MAINTENANCE = true,
    MANAGEMENT = true,
    MEDICAL = true,
    MPT = true,
    ORDERLY = true,
    OWNERSHIP = true,
    PSYHIATRY = true,
    RELATIONS = true,
    SUPERVISION = true
}

-- Killaura логика
RunService.Heartbeat:Connect(function(dt)
	if not Killaura_Module or not killauraEnabled then
		targetHighlight.Adornee = nil
		return
	end

	local localPlayer = Players.LocalPlayer
	if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
	local hrp = localPlayer.Character.HumanoidRootPart

	local closestPlayer = nil
	local closestDistance = math.huge

	for _, player in pairs(Players:GetPlayers()) do
		if player ~= localPlayer 
			and player.Character 
			and player.Character:FindFirstChild("HumanoidRootPart") 
			and player.Character:FindFirstChild("Humanoid") 
			and player.Character.Humanoid.Health > 0 
			and not isFriend(player)
			and not hasIgnoreUniform(player) then

            local targetTeam = player:GetAttribute("CurrentTeamIndex")
            local myTeam = localPlayer:GetAttribute("CurrentTeamIndex")

            -- Если мы ORDERLY, игнорируем перечисленные команды
            if myTeam == "ORDERLY" and ignoreTeamsForOrderly[targetTeam] then
                continue
            end

			local dist = (hrp.Position - player.Character.HumanoidRootPart.Position).Magnitude
			if dist <= killauraRadius and dist < closestDistance then
				closestDistance = dist
				closestPlayer = player
			end
		end
	end

	if closestPlayer and tick() - lastHitTime >= hitCooldown then
		fireHit(closestPlayer)
		lastHitTime = tick()
	end

	if showTarget and closestPlayer and closestPlayer.Character then
		targetHighlight.Adornee = closestPlayer.Character
		targetHighlight.Color3 = Color3.fromRGB(255, 0, 0)
	else
		targetHighlight.Adornee = nil
	end
end)


-- ⚙️ Элементы GUI
KillauraModule:create_checkbox({
	title = "Enable Killaura",
	flag = "Killaura_Enabled",
	callback = function(v)
		killauraEnabled = v
	end
})

KillauraModule:create_checkbox({
	title = "Show Target",
	flag = "showTarget",
	callback = function(v)
		showTarget = v
	end
})

-- 💥 Слайдер задержки удара
KillauraModule:create_slider({
	title = "Hit Delay",
	value = 0.5,
	minimum_value = 0.1,
	maximum_value = 1.0,
	round_value = 0.1,
	flag = "Killaura_Delay",
	callback = function(v)
		hitCooldown = v
		print("Задержка между ударами:", v)
	end
})


local EmoteTab = Window:create_tab("Emotes", "rbxassetid://10723407389")

local stateemote = false
local EmoteModule = EmoteTab:create_module({
    rich = false,
	section = 'left',
	title = "Emote List",
	description = "Wow REALL???? NOT RAT?? AND MINER???!!",
	flag = "Emote_master",
    callback = function(state)
        print("Emote Module MasterSwitch:", stateemote)
    end
})

local emotes = {
    "Abducted","AirBend","AngelFloat","AngryStomping","Assumptions","BananaPeel","Basket",
    "BasketballHoop","Bayside","B-hop","BirdBrain","Blush","Bow","BrazilianLuffy","Breakdance",
    "BunnyHop","ButterflyKnifeSpin","California","CannonBall","Caramelldansen","ChadFlexing",
    "Chilling","Collapse","CoffinDance","Conga","ConductorWand","CopWithGun","CrissCross",
    "CupidsBow","CuteSelfie","Dab","DefaultDance","DeagleSpin","DefibrillatorFloat","DiaDelicia",
    "Dizzy","DJBooth","DracoShots","EarFloat","EarthBend","Facepalm","FieryFloat","FiftyCal",
    "FireBend","Flare","Flex","Float","FunkedUp","GangnamStyle","Gasp","Glendo","Goblet",
    "GoingDark","Goopie","Gravestone","Grenade","Griddy","GuitarSolo","Gun","Hakari","Hakken",
    "HandsUp","HarmonicAscend","Haven","HeavenlyPray","HeartGoesOut","Honk","HugoDance",
    "ImmortalState","InfEmote","IYG","JumpingJacks","Jumpstyle","Juggling","Kazotsky",
    "KeyboardRage","Kiss","Knighting","KnightKneel","Kneel","Laugh","Lay","LayingOnChair",
    "LockedIn","LunawareSturdy","MagicalGirl","Meditation","Melbourne","Microphone","Mime",
    "Mixing","MoneySpread","Moonwalk","Mewwing","Nod","PewPew","Point","Ponder",
    "PoseidonSit","Pray","Pushup","PuppyEyes","RatDance","Runaway","SaltSprinkle","Salute",
    "Scoreboard","SelfCrown","Selfie","Shy","SideLay","SigmaWalk","Sippin","Smelly","Stomp",
    "Static","SusEmote","TakeTheL","TailWiggle","Throne","TPose","ToxicLaugh","Trash","Trumpet",
    "UFO","Violin","VineBoom","Wand","WaterBend","WaterGun","WaterWalk","Zap","Zelda",
    "Heaven","StankyLeg","BlueWalk","HarlemShake","JerseyShoot","MillyRock","NetspendSpread",
    "Whip","Worm","Sturdy","Jetpack","Bird","Combust","Clanker","RobotDance","ShieldCover",
    "SpearJump","SpearMartialArts","ThisIsSparta","SpartanHonor","Territory","Medicine",
    "VegetableJuice","Polkka","Tetoris","RetryNow","LemonMelonCookie","LovelyCavity",
    "Mesmerizer","Monitoring","SkeletonOrchestra","PrincessBubble","PrincessThrone",
    "PrincessWave","Curtsey","Tea","ZombieWalk","VampireSleep","Thriller","SpookyScarySkeletons","Mummy",
}

for _, emoteName in ipairs(emotes) do
    EmoteModule:create_button({
        title = emoteName,
        callback = function()
            if EmoteModule._state then
                game:GetService("ReplicatedStorage").Features.Emotes.PlayEmote:Fire(emoteName)
            end
        end
    })
end


HelperModuleENABLED = false
local HelperModule = PlayerTab:create_module({
    rich = false,
    section = 'left',
    title = "Helper",
    description = "Helps",
    flag = "Helper_Module",
    callback = function(state)
        HelperModuleENABLED = state
    end
})

HelperModule:create_checkbox({
	title = "[Orderly Team] Auto Arrest",
	flag = "orderly_auto_arrest",
	callback = function(val)
		AutoArrestEnabled = val
		print("Auto Arrest:", val)
	end
})

HelperModule:create_checkbox({
	title = "[Orderly Team] Auto Taser",
	flag = "orderly_auto_taser",
	callback = function(val)
		AutoTaserEnabled = val
		print("Auto Taser:", val)
	end
})

-- 🧭 Вспомогательные функции
local function GetRoot(plr)
	local char = plr.Character
	if char then
		return char:FindFirstChild("HumanoidRootPart")
	end
end

local function GetDistance(a, b)
	if not a or not b then return math.huge end
	return (a.Position - b.Position).Magnitude
end

-- 🧱 Проверка принадлежности к Orderly
local function IsOrderly()
	return LocalPlayer.Team and LocalPlayer.Team.Name == "ORDERLY"
end

-- ⚖️ AUTO ARREST
task.spawn(function()
	while task.wait(ARREST_INTERVAL) do
		if not HelperModuleEnabled then continue end -- ✅ Проверка включён ли модуль
		if not AutoArrestEnabled then continue end
		if not IsOrderly() then continue end

		local myRoot = GetRoot(LocalPlayer)
		if not myRoot then continue end

		for _, plr in ipairs(Players:GetPlayers()) do
			if plr == LocalPlayer then continue end
			if not plr.Team or plr.Team.Name ~= "PATIENT" then continue end
			if not plr:GetAttribute("IsTagged") then continue end
           -- if hasIgnoreUniform(plr) then continue end -- 🚫 не арестовывать форму

			local targetRoot = GetRoot(plr)
			if not targetRoot then continue end

			local distance = GetDistance(myRoot, targetRoot)
			if distance <= ARREST_RADIUS then
				local targetHumanoid = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid")
				if targetHumanoid and targetHumanoid.Health > 0 then
					DetainmentEvent:FireServer(plr)
					print("🔒 Arrested:", plr.Name)
					task.wait(0.3)
				end
			end
		end
	end
end)

-- ⚡ AUTO TASER
local function FindTaser()
	local char = LocalPlayer.Character
	if not char then return nil end
	for _, tool in ipairs(char:GetChildren()) do
		if tool:IsA("Tool") and tool.Name == "Taser" then
			return tool
		end
	end
end

local function GetShootPos()
	local char = LocalPlayer.Character
	if not char then return nil end
	local hrp = char:FindFirstChild("HumanoidRootPart")
	return hrp and (hrp.Position + Vector3.new(0, 1.5, 0))
end

-- 🧱 Проверка прямой видимости (Raycast)
local function HasLineOfSight(fromPos, toPos)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
	rayParams.IgnoreWater = true

	local result = workspace:Raycast(fromPos, (toPos - fromPos), rayParams)
	if result then
		-- Если луч попал во что-то, проверяем, не принадлежит ли это цели
		local hitParent = result.Instance and result.Instance.Parent
		if not hitParent or not hitParent:FindFirstChildOfClass("Humanoid") then
			return false -- ❌ Есть препятствие
		end
	end
	return true -- ✅ Прямая видимость есть
end

local function FindTaserTarget()
	local localPos = GetShootPos()
	if not localPos then return end

	local closest, dist = nil, TASER_RADIUS
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr == LocalPlayer then continue end
		if plr.Team and plr.Team.Name == "PATIENT" and plr:GetAttribute("IsTagged") and not hasIgnoreUniform(plr) then
			local hrp = GetRoot(plr)
			if hrp then
				local d = (localPos - hrp.Position).Magnitude
				if d < dist then
					if HasLineOfSight(localPos, hrp.Position) then -- ✅ проверка сквозь стены
						closest = plr
						dist = d
					else
						-- print("🚫 Препятствие между", LocalPlayer.Name, "и", plr.Name)
					end
				end
			end
		end
	end
	return closest
end

-- 🎇 Визуал луча
local BeamPart, BeamAttach0, BeamAttach1, Beam
local function CreateBeam()
	if BeamPart then BeamPart:Destroy() end
	BeamPart = Instance.new("Part")
	BeamPart.Name = "TaserBeam"
	BeamPart.Anchored = true
	BeamPart.CanCollide = false
	BeamPart.Transparency = 0.3
	BeamPart.Material = Enum.Material.Neon
	BeamPart.Color = Color3.fromRGB(0, 120, 255)
	BeamPart.Size = Vector3.new(0.1, 0.1, 1)
	BeamPart.Parent = workspace

	BeamAttach0 = Instance.new("Attachment", BeamPart)
	BeamAttach1 = Instance.new("Attachment", BeamPart)

	Beam = Instance.new("Beam")
	Beam.Attachment0 = BeamAttach0
	Beam.Attachment1 = BeamAttach1
	Beam.Color = ColorSequence.new(Color3.fromRGB(0, 150, 255))
	Beam.Width0 = 0.25
	Beam.Width1 = 0.25
	Beam.FaceCamera = true
	Beam.LightEmission = 1
	Beam.Parent = BeamPart
end

local function UpdateBeam(startPos, endPos)
	if not BeamPart then CreateBeam() end
	local dir = (endPos - startPos)
	local dist = dir.Magnitude
	BeamPart.CFrame = CFrame.lookAt(startPos, endPos)
	BeamPart.Size = Vector3.new(0.1, 0.1, dist)
	BeamAttach0.WorldPosition = startPos
	BeamAttach1.WorldPosition = endPos
end

local function RemoveBeam()
	if BeamPart then BeamPart:Destroy() end
	BeamPart, BeamAttach0, BeamAttach1, Beam = nil
end

task.spawn(function()
	while task.wait(TASER_INTERVAL) do
		if not HelperModuleENABLED then continue end -- ✅ Проверка включён ли модуль
		if not AutoTaserEnabled then continue end
		if not IsOrderly() then continue end

		local tool = FindTaser()
		if not tool then continue end

		local target = FindTaserTarget()
		if not target then RemoveBeam() continue end

		-- ⚠ Проверка атрибута CurrentTeamIndex
		if target:GetAttribute("CurrentTeamIndex") == 5 then
			RemoveBeam()
			continue
		end

		local targetRoot = GetRoot(target)
		local startPos = GetShootPos()
		if not targetRoot or not startPos then continue end

		UpdateBeam(startPos, targetRoot.Position)

		local event = tool:FindFirstChild("TaserEvent")
		if event then
			-- ⚡ Активируем саму стрельбу тазером
			event:InvokeServer("Tase", targetRoot)
			print("⚡ Tased:", target.Name)
		end

		task.delay(BEAM_DURATION, RemoveBeam)
		task.wait(1)
	end
end)

-- Автоматически добавляем существующих друзей при запуске
task.spawn(function()
	wait(3) -- Ждем загрузки
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= Players.LocalPlayer then
			local success, isFriendResult = pcall(function()
				return Players.LocalPlayer:IsFriendsWith(player.UserId)
			end)
			
			if success and isFriendResult then
				addFriend(player.Name)
			end
		end
	end
end)


-- // 👁️ ESP: Красивые боксы + Name/Health
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local ESP_Module_Active = false
local ESP_Enabled = false
local ESP_Objects = {}
local ESP_Type = "Custom" -- "Gradient", "Neon", "Custom"
local ESP_Color = Color3.fromRGB(255,0,0)
local ESP_Transparency = 0.6
local ESP_LineThickness = 0.05
local ESP_GradientSpeed = 2 -- скорость градиента
local r, g, b = 255,0,0

local ESPModule = VisualsTab:create_module({
    rich = false,
    section = 'right',
    title = "ESP",
    description = "Боксы + Имя/Здоровье",
    flag = "ESP_Module",
    callback = function(state)
        ESP_Module_Active = state
    end
})

-- Чекбокс включения ESP
ESPModule:create_checkbox({
    title = "Enable ESP",
    flag = "ESP_Enabled",
    callback = function(val)
        ESP_Enabled = val
        if not val then
            for _, obj in pairs(ESP_Objects) do
                obj.Box:Destroy()
                obj.Text:Destroy()
            end
            table.clear(ESP_Objects)
        end
    end
})

-- Dropdown: Тип подсветки
ESPModule:create_dropdown({
    title = "ESP Type",
    options = {"Gradient","Neon","Custom"},
    flag = "ESP_Type",
    maximum_options = 3,
    callback = function(val)
        ESP_Type = val
    end
})

-- RGB слайдеры для Custom
ESPModule:create_slider({
    title = "Red",
    value = r,
    minimum_value = 0,
    maximum_value = 255,
    round_number = 1,
    flag = "Red",
    callback = function(val)
        r = val
        ESP_Color = Color3.fromRGB(r,g,b)
    end
})

ESPModule:create_slider({
    title = "Green",
    value = g,
    minimum_value = 0,
    maximum_value = 255,
    round_number = 1,
    flag = "Green",
    callback = function(val)
        g = val
        ESP_Color = Color3.fromRGB(r,g,b)
    end
})

ESPModule:create_slider({
    title = "Blue",
    value = b,
    minimum_value = 0,
    maximum_value = 255,
    round_number = 1,
    flag = "Blue",
    callback = function(val)
        b = val
        ESP_Color = Color3.fromRGB(r,g,b)
    end
})


-- Создание ESP объектов
local function createESP(character)
    if not character or ESP_Objects[character] then return end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not hrp or not humanoid then return end

    local box = Instance.new("BoxHandleAdornment")
    box.Size = Vector3.new(4,6,2)
    box.Adornee = hrp
    box.AlwaysOnTop = true
    box.Transparency = ESP_Transparency
    box.Color3 = ESP_Color
    box.ZIndex = 2
    box.Parent = game.CoreGui

    local billboard = Instance.new("BillboardGui")
    billboard.Size = UDim2.new(0,100,0,50)
    billboard.Adornee = hrp
    billboard.AlwaysOnTop = true
    billboard.Parent = game.CoreGui

    local text = Instance.new("TextLabel")
    text.Size = UDim2.new(1,0,1,0)
    text.BackgroundTransparency = 1
    text.TextColor3 = ESP_Color
    text.TextStrokeTransparency = 0
    text.TextScaled = true
    text.Font = Enum.Font.ArialBold
    text.Parent = billboard

    ESP_Objects[character] = {Box = box, Text = text, Humanoid = humanoid}
end


-- Удаление ESP
local function removeESP(character)
    if ESP_Objects[character] then
        ESP_Objects[character].Box:Destroy()
        ESP_Objects[character].Text:Destroy()
        ESP_Objects[character] = nil
    end
end

-- Градиентный цвет HSV
local function gradientColor(t)
    local hue = (tick() * ESP_GradientSpeed + t) % 1
    return Color3.fromHSV(hue,1,1)
end

-- Обновление ESP каждый кадр
RunService.RenderStepped:Connect(function()
    if not ESP_Module_Active or not ESP_Enabled then
        for _, obj in pairs(ESP_Objects) do
            obj.Box.Visible = false
            obj.Text.Visible = false
        end
        return
    end

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            if not ESP_Objects[plr.Character] then
                createESP(plr.Character)
            end

            local obj = ESP_Objects[plr.Character]
            if obj then
                local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
                if hrp then obj.Box.Adornee = hrp obj.Text.Parent.Adornee = hrp end
                obj.Box.Visible = true
                obj.Text.Visible = true

                -- Цвет
                if ESP_Type == "Gradient" then
                    obj.Box.Color3 = gradientColor(plr.UserId)
                    obj.Text.TextColor3 = gradientColor(plr.UserId)
                    obj.Box.Transparency = 0.5
                elseif ESP_Type == "Neon" then
                    obj.Box.Color3 = Color3.fromRGB(0,255,255)
                    obj.Text.TextColor3 = Color3.fromRGB(0,255,255)
                    obj.Box.Transparency = 0.3
                else -- Custom
                    obj.Box.Color3 = ESP_Color
                    obj.Text.TextColor3 = ESP_Color
                    obj.Box.Transparency = ESP_Transparency
                end

                -- Текст: имя + здоровье
                local hum = obj.Humanoid
                if hum then
                    obj.Text.Text = plr.Name.." ["..math.floor(hum.Health).."]"
                end
            end
        else
            removeESP(plr.Character)
        end
    end

    -- Очистка для вышедших игроков
    for char, _ in pairs(ESP_Objects) do
        local exists = false
        for _, plr in pairs(Players:GetPlayers()) do
            if plr.Character == char then exists = true break end
        end
        if not exists then removeESP(char) end
    end
end)

-- Автосоздание для новых персонажей
Players.PlayerAdded:Connect(function(plr)
    plr.CharacterAdded:Connect(function(char)
        if ESP_Enabled and ESP_Module_Active then createESP(char) end
    end)
end)

-- Очистка при выходе игрока
Players.PlayerRemoving:Connect(function(plr)
    removeESP(plr.Character)
end)

-- // 🎯 Anti Ragdoll + Anchored (один чекбокс)
local antiRagdollEnabled = false

-- Добавляем один чекбокс в существующий Malicious модуль
MaliciousModule:create_checkbox({
    title = "Anti Ragdoll + Anchored", 
    flag = "AntiRagdoll_Enabled",
    callback = function(val)
        antiRagdollEnabled = val
        
        if val then
            Library.SendNotification({
                title = "Anti Ragdoll",
                text = "Анти-ragdoll + Anchored активирован!",
                duration = 3
            })
            
            -- Сразу применяем anchored к текущему персонажу
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                character.HumanoidRootPart.Anchored = false
            end
        else
            -- При выключении снимаем anchored
            local character = LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                character.HumanoidRootPart.Anchored = false
            end
            
            Library.SendNotification({
                title = "Anti Ragdoll", 
                text = "Анти-ragdoll + Anchored выключен",
                duration = 3
            })
        end
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Функция проверки свободного пространства
local function isSpaceFree(position, checkHeight)
    local rayOrigin = position + Vector3.new(0, 2, 0)
    local rayDirection = Vector3.new(0, checkHeight, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    if LocalPlayer.Character then
        raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    end
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    return raycastResult == nil
end

-- Функция поиска свободного места
local function findFreePosition(startPosition)
    local directions = {
        Vector3.new(0, 15, 0),
        Vector3.new(5, 15, 0),
        Vector3.new(-5, 15, 0), 
        Vector3.new(0, 15, 5),
        Vector3.new(0, 15, -5),
        Vector3.new(0, 25, 0)
    }
    
    for _, direction in ipairs(directions) do
        local testPosition = startPosition + direction
        if isSpaceFree(testPosition, 5) then
            return testPosition
        end
    end
    
    return startPosition + Vector3.new(0, 15, 0)
end

-- Основной цикл анти-ragdoll
RunService.Heartbeat:Connect(function()
    if not antiRagdollEnabled then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local hrp = character:FindFirstChild("HumanoidRootPart")
    
    if humanoid and hrp then
        -- Всегда включаем anchored когда чекбокс активен
        hrp.Anchored = true
        
        -- Обработка ragdoll
        if humanoid.PlatformStand then
            -- Игрок в ragdoll состоянии
            local freePosition = findFreePosition(hrp.Position)
            
            -- Телепортируемся и выходим из ragdoll
            hrp.CFrame = CFrame.new(freePosition)
            humanoid.PlatformStand = false
            
            -- Небольшая задержка для стабилизации
            wait(0.2)
            humanoid.PlatformStand = false
        end
    end
end)

-- Обрабатываем появление нового персонажа
LocalPlayer.CharacterAdded:Connect(function(character)
    wait(1) -- Ждем полной загрузки персонажа
    
    if antiRagdollEnabled then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            hrp.Anchored = true
        end
    end
end)

local enabled = false
local heartbeatConnection = nil
local part = nil
local hrp1 = nil

local function stopScript()
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
    
    if part then
        part:Destroy()
        part = nil
    end
    
    if hrp1 then
        hrp1:Destroy()
        hrp1 = nil
    end
    
    -- Восстанавливаем оригинального персонажа
    local lp = game.Players.LocalPlayer
    if lp.Character then
        lp.Character:BreakJoints()
    end
end

local function startScript()
    stopScript() -- Останавливаем предыдущий запуск, если был
    
    local CreditAndInfo = true
    local height = 3

    local cloneref = cloneref or function(o) return o end

    if height > 4 then
        height = 4
    end

    -- Copying Player
    local lp = game.Players.LocalPlayer
    local c = lp.Character or lp.CharacterAdded:Wait()
    local hrp0 = c:WaitForChild("HumanoidRootPart")
    hrp1 = hrp0:Clone()

    -- Just where Bubble Chat Appear Part
    part = Instance.new("Part")
    part.Size = Vector3.new(0.5, 0.5, 0.5)
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 0.5
    part.BrickColor = BrickColor.new("Bright blue")
    part.Parent = workspace

    -- Отключаем коллизию для всех частей персонажа
    for _, child in ipairs(c:GetChildren()) do
        if child:IsA("BasePart") and child ~= hrp0 then
            child.CanCollide = false
        end
    end

    -- Ищем RootJoint в Humanoid, а не в HumanoidRootPart
    local humanoid = c:WaitForChild("Humanoid")
    local rootJoint = c:FindFirstChild("RootJoint") or humanoid:FindFirstChild("RootJoint")
    
    c.Parent = nil
    hrp0.Parent = hrp1
    
    if rootJoint then
        rootJoint.Part0 = nil
    end
    
    hrp1.Parent = c
    c.Parent = workspace

    hrp1.CanCollide = true

    local animId = "rbxassetid://215384594"
    local anim = Instance.new("Animation")
    anim.AnimationId = animId
    local animTrack = humanoid:LoadAnimation(anim)

    local h = game:GetService("RunService").Heartbeat
    heartbeatConnection = h:Connect(function()
        if not c or not c.Parent or not enabled then
            stopScript()
            return
        end
        
        humanoid.HipHeight = height
        humanoid.JumpPower = 20
        animTrack:Play()
        animTrack:AdjustSpeed(0)
        animTrack.TimePosition = 0.4
        hrp0.CFrame = hrp1.CFrame 
        hrp0.Orientation = Vector3.new(90, 0, 0)
        hrp0.Position = hrp1.Position - Vector3.new(0, hrp0.Size.Y / 2, 0) 
        hrp0.Velocity = hrp1.Velocity

        part.Position = hrp0.Position + Vector3.new(-0.05, 0, 2.45)
    end)
end

local function toggleUndergroundChat()
    enabled = not enabled
    if enabled then
        startScript()
        undergroundChatButton:set_text("invisible")
    else
        stopScript()
        undergroundChatButton:set_text("invisible")
    end
end

MaliciousModule:create_button({
    title = "invisible",
    callback = function()
        toggleUndergroundChat()
    end
})

local ShopTab = Window:create_tab("Shop", "rbxassetid://10723407389")

local PatientModule = ShopTab:create_module({
    rich = false,
    section = 'left',
    title = "Patient Shop",
    description = "Buy specific items from the patient shop",
    flag = "shop_patient",
    callback = function(state)
        print("Patient Shop state:", state)
    end
})

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")

local ShopRemote = ReplicatedStorage:WaitForChild("Remote"):WaitForChild("ShopInteract")
local Shopkeeper = workspace:WaitForChild("Shopkeepers"):WaitForChild("PatientShopkeeper"):WaitForChild("John") or print("Not found")

local shopPosition = CFrame.new(
    47.499218, 254.500015, -698.279053,
    -0.0137896948, 8.52515711e-08, 0.999904931,
    -3.0181198e-08, 1, -8.56759073e-08,
    -0.999904931, -3.13597717e-08, -0.0137896948
)

local itemList = {
    "Glass Shard",
    "Stolen Staff Card",
    "Molotov",
    "Metal Shard",
    "Crowbar",
    "StolenRadio",
    "ECM Jammer",
    "Glass Fragment",
    "Wooden Bat",
    "Landmine",
    "Gasmask",
    "Bomb",
    "Sticky Bomb"
}

local function purchaseItem(itemName)
    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local root = character:WaitForChild("HumanoidRootPart")


    local savedPos = root.CFrame


    root.CFrame = shopPosition
    task.wait(0.1)

  
    local args = {Shopkeeper, "Purchase", "Item", itemName}
    local success, err = pcall(function()
        ShopRemote:InvokeServer(unpack(args))
    end)

    if success then
        print("[Shop] Corect!:", itemName)
    else
        warn("[Shop] Error:", err)
    end

    task.wait(0.25)
    root.CFrame = savedPos
end

for _, itemName in ipairs(itemList) do
    PatientModule:create_button({
        title = "Buy " .. itemName,
        description = "autoshop " .. itemName,
        callback = function()
            purchaseItem(itemName)
        end
    })
end

-- 📜 Список доступных титлов
local Titles = {
    "VIPTitle","InformedTitle","HitmanTitle","KillerTitle","AssassinTitle","ExecutionerTitle","DeathBringerTitle",
    "SoulCollectorTitle","BabaYagaTitle","InexorableTitle","BrawlerTitle","WarriorTitle","DuelistTitle","GladiatorTitle",
    "ChampionTitle","UnstoppableTitle","MurdererTitle","VengefulTitle","MonstrosityTitle","RagefulTitle","BerzerkerTitle",
    "DoombringerTitle","PocketMedicTitle","GuardianTitle","ReviverTitle","HeroicTitle","AngelTitle","SaviorTitle","ProtectorTitle",
    "PeaceKeeperTitle","SentinelTitle","WardenTitle","CommandantTitle","IronwatchTitle","RunawayTitle","FugitiveTitle","OutlawTitle",
    "EscapistTitle","EluderTitle","SlickTitle","GhostTitle","PhantomTitle","HoudiniTitle","SorcererTitle","SamuraiTitle","DemonTitle",
    "PoseidonTitle","MangomaniacTitle","IntergalacticTitle","PrincessTitle","PainterTitle","ArtistTitle","VisionaryTitle","JanitorTitle",
    "CustodianTitle","GermaphobeTitle","MopMaestroTitle","FloorWhispererTitle","MasterOfTheMopTitle","DeusExMopinaTitle","SultanOfShineTitle",
    "TheMopinatorTitle","ClearMindedTitle","FryCookTitle","LineCookTitle","RoundsmanTitle","GrillGuardianTitle","SousChefTitle",
    "StationChefTitle","MasterChefTitle","CulinaryDirectorTitle","ChefDeCuisineTitle","NumberOneGlobalAssassin","NumberOneGlobalFighter",
    "NumberOneGlobalHealer","NumberOneGlobalEscapee","NumberOneGlobalArrestor","NumberOneGlobalTaskManager","NumberOneGlobalExecutioner",
    "NumberOneGlobalProsperity","NumberOneGlobalDonator","NumberTwoGlobalAssassin","NumberTwoGlobalFighter","NumberTwoGlobalHealer",
    "NumberTwoGlobalEscapee","NumberTwoGlobalArrestor","NumberTwoGlobalTaskManager","NumberTwoGlobalExecutioner","NumberTwoGlobalProsperity",
    "NumberTwoGlobalDonator","NumberThreeGlobalAssassin","NumberThreeGlobalFighter","NumberThreeGlobalHealer","NumberThreeGlobalEscapee",
    "NumberThreeGlobalArrestor","NumberThreeGlobalTaskManager","NumberThreeGlobalExecutioner","NumberThreeGlobalProsperity",
    "NumberThreeGlobalDonator","RetirementBaseTitle","PraetorianTitle","MaximusMedicusTitle","TheTerminatorTitle","AllSeeingTitle",
    "LordofWolvesTitle","BiohazardTitle","ConfettiTitle","LunawareTitle","ShoobTitle","EntropicTitle","TerminalGUITitle","LilithTitle",
    "DissonanceTitle","PastelRainbowTitle","DeveloperTitle","LovestruckTitle","SixEyesTitle","LimitlessTitle","UzumakiTitle","UserPrincess",
    "KittyCat","LarpyClassifiedTitle","ContentCreatorTitle","ModeratorTitle","CommunityAffairsTitle","ZudaranTitle","ArticTitle","IlluTitle",
    "LifeyTitle","LifeyTitle2","ReverieTitle","AkuaTitle","ZudaranTitle2","InfTitle1","InfTitle2","MioTitle","FruitfulTitle","MysteryTitle",
    "LuckyTitle","BunnyTitle","PinkBeretTitle","ClownTitle","SixSevenTitle","WhiteHatTitle","QualityAssuranceTitle","EightySeven"
}

-- 🧩 Переменные состояния
local Players = game:GetService("Players")
local Player = Players.LocalPlayer
local originalTitle = nil
local isCustomTitleEnabled = false
local currentSelectedTitle = nil

-- ⚙️ Функции
local function setTitle(title)
    if not Player or not title then return end
    Player:SetAttribute("CurrentTitleEquipped", title)
    print("[Title System] Set title:", title)
end

local function getCurrentTitle()
    if not Player then return nil end
    return Player:GetAttribute("CurrentTitleEquipped")
end
local LocalPlayer_Masterw = false
local VisualPlayeronly = VisualsTab:create_module({
  	rich = false,
	section = 'left',
	title = "LocalPlayer",
	description = " ",
    flag = "Localplayer_Masterw",
    callback = function(state)
        print("Localplayer_Masterw:", state)
    end
})
local Indicator_Masterw = false
local Indicator_Master = VisualsTab:create_module({
  	rich = false,
	section = 'left',
	title = "Indicators",
	description = " ",
    flag = "Indicator_Masterw",
    callback = function(state)
        print("Indicator_Masterw:", state)
    end
})

function create_indicatortimer()
	local gui = Instance.new("ScreenGui")
	local Frame = Instance.new("Frame")
	local TextLabel = Instance.new("TextLabel")
	local UICorner = Instance.new("UICorner")
	local UIGradient = Instance.new("UIGradient")
	local UICorner_2 = Instance.new("UICorner")

	local tv = workspace.A_MAP.Infrastructure.Facility.UndergroundFacility.ChillSpotGrid
		.AdjustableTV.InteractableTV.Screen.Event.Background.Title

	local text = tv.Text
	local timer = string.match(text, "%d+:%d+") or "00:00"

	gui.Name = "64a25eca9bb1909209038186700000778"
	gui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
	gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	gui.ResetOnSpawn = false

	Frame.Parent = gui
	Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	Frame.BackgroundTransparency = 0.25
	Frame.BorderSizePixel = 0
	Frame.Position = UDim2.new(0.0059, 0, 0.477, 0)
	Frame.Size = UDim2.new(0, 50, 0, 46)

	TextLabel.Parent = Frame
	TextLabel.BackgroundTransparency = 1
	TextLabel.Position = UDim2.new(0, 0, 0, 0)
	TextLabel.Size = UDim2.new(1, 0, 1, 0)
	TextLabel.Font = Enum.Font.FredokaOne
	TextLabel.Text = timer
	TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	TextLabel.TextScaled = true
	TextLabel.TextWrapped = true

	UICorner.CornerRadius = UDim.new(0, 50)
	UICorner.Parent = TextLabel

	UIGradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0.00, Color3.fromRGB(97, 97, 97)),
		ColorSequenceKeypoint.new(0.18, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(0.82, Color3.fromRGB(255, 255, 255)),
		ColorSequenceKeypoint.new(1.00, Color3.fromRGB(97, 97, 97))
	}
	UIGradient.Parent = TextLabel

	UICorner_2.CornerRadius = UDim.new(0, 50)
	UICorner_2.Parent = Frame

	task.spawn(function()
		while gui.Parent do
			local text = tv.Text
			local timer = string.match(text, "%d+:%d+") or "00:00"
			TextLabel.Text = timer
			task.wait(0.5)
		end
	end)
end


Indicator_Master:create_checkbox({
	title = "Event Timer",
	flag = "event_timer",
	callback = function(val)
		if val then
			create_indicatortimer()
		else
			local gui = game.Players.LocalPlayer.PlayerGui:FindFirstChild("64a25eca9bb1909209038186700000778")
			if gui then gui:Destroy() end
		end
	end
})



VisualPlayeronly:create_dropdown({
    title = "Custom Title",
    flag = "custom_title_dropdown",
    options = Titles,
    maximum_options = 10,
    multi_dropdown = false,
    callback = function(option)
        currentSelectedTitle = option
        print("[Title System] Selected:", option)
        if isCustomTitleEnabled and option then
            setTitle(option)
        end
    end
})



VisualPlayeronly:create_checkbox({
    title = "Enable Custom Titles",
    flag = "enable_custom_titles",
    callback = function(value)
        isCustomTitleEnabled = value
        print("[Title System] Custom Titles Enabled:", value)

        if value then
            -- Сохраняем оригинальный титл при включении
            originalTitle = getCurrentTitle()

            -- Применяем выбранный или первый доступный
            if currentSelectedTitle then
                setTitle(currentSelectedTitle)
            else
                currentSelectedTitle = Titles[1]
                setTitle(currentSelectedTitle)
            end
        else
            -- Возвращаем оригинальный титл
            if originalTitle then
                setTitle(originalTitle)
            else
                -- Если не было — очищаем
                Player:SetAttribute("CurrentTitleEquipped", nil)
            end
        end
    end
})

-- // Auto Heal Module
local AutoHealModule = PlayerTab:create_module({
	title = "Auto Heal System",
	description = "Heal allies automatically in range",
	section = "left",
	flag = "auto_heal_module",
	callback = function(state)
		_G.AutoHealEnabled = state
		if not state then
			_G.AutoHealRunning = false
		end
	end
})



-- ⚙️ Настройки
local healWithKits = false
local healWithMedigun = false
local healRadius = 10
local SelectedTeams = {}

-- 🚫 Форма, которую не трогаем (игнорируем)
local IGNORE_SHIRT = "rbxassetid://12001628840"
local IGNORE_PANTS = "rbxassetid://12001628486"

-- 🧍‍♂️ Проверка формы
local function hasIgnoreUniform(player)
	local char = player.Character
	if not char then return false end

	local shirt = char:FindFirstChildOfClass("Shirt")
	local pants = char:FindFirstChildOfClass("Pants")

	if not shirt or not pants then return false end

	return (shirt.ShirtTemplate == IGNORE_SHIRT and pants.PantsTemplate == IGNORE_PANTS)
end

-- ✅ Команды
local TeamList = {
	"CHOOSING","COMMUNITY","DEVELOPER","ETHICS","HEADMANAGEMENT","IGNOTUS",
	"JANITOR","MAINTENANCE","MEDICAL","MPT","ORDERLY","OWNERSHIP","PARTNER",
	"PATIENT","PSYCHIATRY","RELATIONS","SUPERVISION","AFFILIATE","BOXED"
}

-- 🧩 Чекбоксы и слайдеры
AutoHealModule:create_checkbox({
	title = "Heal with Medical Kits (Large, Quik-Fix)",
	flag = "heal_kits",
	callback = function(state)
		healWithKits = state
	end
})

AutoHealModule:create_checkbox({
	title = "Heal with Medigun",
	flag = "heal_medigun",
	callback = function(state)
		healWithMedigun = state
	end
})

AutoHealModule:create_slider({
	title = "Heal Radius",
	flag = "heal_radius",
	minimum_value = 5,
	maximum_value = 20,
	value = 10,
	round_number = true,
	callback = function(value)
		healRadius = value
	end
})

local Teams = {
    "CHOOSING", "COMMUNITY", "DEVELOPER", "ETHICS", "HEADMANAGEMENT",
    "IGNOTUS", "JANITOR", "MAINTENANCE", "MEDICAL", "MPT",
    "ORDERLY", "OWNERSHIP", "PARTNER", "PATIENT", "PSYCHIATRY",
    "RELATIONS", "SUPERVISION", "AFFILIATE", "BOXED"
}

-- таблица для хранения выбранных
local SelectedTeams = {}

-- создаём чекбоксы
for _, team in ipairs(Teams) do
    AutoHealModule:create_checkbox({
        title = team,
        flag = "team_" .. team,
        callback = function(value)
            if value then
                SelectedTeams[team] = true
            else
                SelectedTeams[team] = nil
            end
            print("Selected Teams:", SelectedTeams)
        end
    })
end

-- 💫 Визуальный радиус
local player = game.Players.LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local hrp = char:WaitForChild("HumanoidRootPart")

-- 💉 Основной цикл хила
task.spawn(function()
	local remote = game:GetService("ReplicatedStorage"):WaitForChild("Remote")
	local healEvent = remote:FindFirstChild("AttemptHeal")
	local medigunEvent = remote:FindFirstChild("MedigunEvent")

	while task.wait(0.5) do
		if not _G.AutoHealEnabled then continue end
		local char = player.Character
		if not char or not char:FindFirstChild("HumanoidRootPart") then continue end

		local root = char.HumanoidRootPart
		local nearest, lowestHealth = nil, math.huge

		for _, plr in ipairs(game.Players:GetPlayers()) do
			if plr == player then continue end
			if not plr.Team or not SelectedTeams[plr.Team.Name] then continue end
			if hasIgnoreUniform(plr) then continue end

			local humanoid = plr.Character and plr.Character:FindFirstChild("Humanoid")
			local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
			if not humanoid or not hrp then continue end

			local dist = (hrp.Position - root.Position).Magnitude
			if humanoid.Health > 0 and humanoid.Health < humanoid.MaxHealth and dist <= healRadius then
				if humanoid.Health < lowestHealth then
					nearest = plr
					lowestHealth = humanoid.Health
				end
			end
		end

		if nearest then
			if healWithKits and healEvent then
				healEvent:FireServer(nearest)
			end
			if healWithMedigun and medigunEvent then
				medigunEvent:FireServer(nearest)
			end
		else
            warn("HVH BIBIZAKA")
		end
	end
end)
Library.SendNotification({
    title = "Lolsense",
    text = "Script Loaded!",
    duration = 5
})
